<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Moka Man: Espresso Surfers Pro</title>
    <style>
        :root {
            --moka-brown: #4e342e;
            --moka-light: #8d6e63;
            --bg-color: #fbe9e7;
            --power-magnet: #2196F3;
            --power-shield: #00E676;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--moka-brown);
            font-weight: bold;
            font-size: 28px;
            pointer-events: none;
            text-shadow: 2px 2px 0 rgba(255,255,255,0.8);
            z-index: 10;
        }

        #powerup-status {
            position: absolute;
            top: 60px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .status-bar {
            height: 8px;
            background: rgba(0,0,0,0.1);
            border-radius: 4px;
            width: 100px;
            overflow: hidden;
            display: none;
        }

        .status-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 2rem;
            border-radius: 30px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border: 5px solid var(--moka-brown);
            z-index: 20;
            min-width: 320px;
        }

        h1 { color: var(--moka-brown); margin: 0 0 10px 0; font-size: 28px; letter-spacing: 2px; }
        p { color: #5d4037; margin-bottom: 20px; line-height: 1.4; font-size: 15px; }
        
        button {
            background: var(--moka-brown);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 40px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 0 #2e1b18;
        }

        button:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 #2e1b18;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-overlay">Score: <span id="score">0</span></div>
    <div id="powerup-status">
        <div id="magnet-ui" class="status-bar"><div class="status-fill" style="background: var(--power-magnet)"></div></div>
        <div id="shield-ui" class="status-bar"><div class="status-fill" style="background: var(--power-shield)"></div></div>
    </div>
    <div id="menu">
        <h1 id="menu-title">ESPRESSO SURFERS</h1>
        <p id="menu-text">A/D: Move | W: Jump | S: Fall<br>Run on cartons to survive!</p>
        <button id="start-btn">BREW START</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    const LANES = [-2.5, 0, 2.5];
    const GRAVITY = -0.016;
    const JUMP_FORCE = 0.4;
    const PLAYER_Y_OFFSET = 0.6;
    const CARTON_HEIGHT = 2.0;
    const CARTON_LENGTH = 12;
    const RAMP_LENGTH = 6;
    
    let scene, camera, renderer, mokaMan, shieldBubble;
    let gameActive = false;
    let score = 0;
    let speed = 0.25; 
    let currentLaneIndex = 1;
    let targetX = LANES[1];
    let velocityY = 0;
    let currentGroundY = PLAYER_Y_OFFSET;

    let magnetTimer = 0;
    let shieldTimer = 0;
    const POWERUP_DURATION = 600; 

    let entities = [];
    const scoreEl = document.getElementById('score');
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('start-btn');
    const menuTitle = document.getElementById('menu-title');
    const menuText = document.getElementById('menu-text');
    const magnetUI = document.getElementById('magnet-ui');
    const shieldUI = document.getElementById('shield-ui');

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfbe9e7);
        scene.fog = new THREE.Fog(0xfbe9e7, 20, 60);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 10);
        camera.lookAt(0, 1, -5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 15, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        createMokaMan();
        createEnvironment();

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('keydown', handleKeyDown);
        startBtn.addEventListener('click', startGame);

        animate();
    }

    function createMokaMan() {
        const group = new THREE.Group();
        const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 32, 16),
            new THREE.MeshStandardMaterial({ color: 0x4e342e })
        );
        body.scale.set(1, 1.2, 0.8);
        body.castShadow = true;
        group.add(body);

        const hat = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.3, 0.4, 8),
            new THREE.MeshStandardMaterial({ color: 0x9e9e9e, metalness: 0.9, roughness: 0.1 })
        );
        hat.position.y = 0.7;
        group.add(hat);

        const bubbleGeo = new THREE.SphereGeometry(1.1, 32, 32);
        const bubbleMat = new THREE.MeshStandardMaterial({ 
            color: 0x00E676, transparent: true, opacity: 0.3, emissive: 0x00E676, emissiveIntensity: 0.5
        });
        shieldBubble = new THREE.Mesh(bubbleGeo, bubbleMat);
        shieldBubble.visible = false;
        group.add(shieldBubble);

        group.position.y = PLAYER_Y_OFFSET;
        mokaMan = group;
        scene.add(mokaMan);
    }

    function createEnvironment() {
        const floorGeo = new THREE.PlaneGeometry(12, 2000);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xeedcbd });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        for (let i = -1.5; i <= 1.5; i++) {
            const line = new THREE.Mesh(
                new THREE.PlaneGeometry(0.15, 2000),
                new THREE.MeshStandardMaterial({ color: 0xd7ccc8 })
            );
            line.position.set(i * 2.5, 0.01, 0);
            line.rotation.x = -Math.PI / 2;
            scene.add(line);
        }
    }

    function spawnEntity(type, laneIdx, zPos) {
        let mesh;
        let data = { type, lane: laneIdx, mesh: null };

        if (type === 'carton') {
            mesh = new THREE.Mesh(
                new THREE.BoxGeometry(2.3, CARTON_HEIGHT, CARTON_LENGTH),
                new THREE.MeshStandardMaterial({ color: 0xffffff })
            );
            mesh.position.set(LANES[laneIdx], CARTON_HEIGHT / 2, zPos);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            data.height = CARTON_HEIGHT;
            data.length = CARTON_LENGTH;
        } else if (type === 'ramp') {
            mesh = new THREE.Mesh(
                new THREE.BoxGeometry(2.3, 0.2, RAMP_LENGTH),
                new THREE.MeshStandardMaterial({ color: 0x8d6e63 })
            );
            // The ramp tilts "up" towards the negative Z (where cartons are)
            mesh.rotation.x = Math.atan(CARTON_HEIGHT / RAMP_LENGTH);
            // Positioned half a ramp length in front of where the carton would start
            mesh.position.set(LANES[laneIdx], CARTON_HEIGHT / 2, zPos + (CARTON_LENGTH/2) + (RAMP_LENGTH/2));
            data.height = CARTON_HEIGHT;
        } else if (type === 'spill') {
            mesh = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1.5, 0.1, 16),
                new THREE.MeshStandardMaterial({ color: 0x3e2723, transparent: true, opacity: 0.9 })
            );
            mesh.position.set(LANES[laneIdx], 0.05, zPos);
        } else if (type === 'bean') {
            mesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0xffd54f, emissive: 0xffb300, emissiveIntensity: 0.6 })
            );
            mesh.scale.set(1, 1.4, 0.8);
            mesh.position.set(LANES[laneIdx], 1.0, zPos);
        } else if (type === 'power_magnet') {
            mesh = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.1, 8, 16), new THREE.MeshStandardMaterial({color: 0x2196F3}));
            mesh.position.set(LANES[laneIdx], 1.2, zPos);
        } else if (type === 'power_shield') {
            mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.4), new THREE.MeshStandardMaterial({color: 0x00E676}));
            mesh.position.set(LANES[laneIdx], 1.2, zPos);
        }

        data.mesh = mesh;
        entities.push(data);
        scene.add(mesh);
    }

    function spawnRow() {
        const z = -100;
        const rand = Math.random();
        
        // Impossible wall prevention: Always ensure at least one path
        // 0: Carton+Ramp, 1: Carton (Block), 2: Spill, 3: Empty
        const layout = [3, 3, 3];
        
        if (rand < 0.4) {
            // One blocked, two clear
            layout[Math.floor(Math.random()*3)] = 1;
        } else if (rand < 0.7) {
            // Two blocked, but one MUST have a ramp
            const blockedLanes = [0, 1, 2].sort(() => 0.5 - Math.random()).slice(0, 2);
            layout[blockedLanes[0]] = 0; // Ramp
            layout[blockedLanes[1]] = 1; // Block
        } else {
            // One spill, others random
            layout[Math.floor(Math.random()*3)] = 2;
        }

        layout.forEach((type, lane) => {
            if (type === 0) {
                spawnEntity('carton', lane, z);
                spawnEntity('ramp', lane, z);
            } else if (type === 1) {
                spawnEntity('carton', lane, z);
            } else if (type === 2) {
                spawnEntity('spill', lane, z);
            }
        });

        // Spawn Bean clusters in empty or over path
        if (Math.random() < 0.7) {
            const bLane = Math.floor(Math.random()*3);
            const isOnCarton = layout[bLane] === 0 || layout[bLane] === 1;
            const startZ = z - 10;
            const count = 5 + Math.floor(Math.random()*5);
            for(let i=0; i<count; i++) {
                const beanZ = startZ + (i * 2);
                spawnEntity('bean', bLane, beanZ);
                // Adjust height if on carton
                if (isOnCarton) entities[entities.length-1].mesh.position.y = CARTON_HEIGHT + 1.0;
            }
        }

        // Rare Powerup
        if (Math.random() < 0.05) {
            spawnEntity(Math.random() > 0.5 ? 'power_magnet' : 'power_shield', Math.floor(Math.random()*3), z - 20);
        }
    }

    function moveLane(dir) {
        if (!gameActive) return;
        currentLaneIndex = THREE.MathUtils.clamp(currentLaneIndex + dir, 0, 2);
        targetX = LANES[currentLaneIndex];
    }

    function handleJump() {
        if (!gameActive) return;
        // Strict jump check: only on ground or platform
        if (Math.abs(mokaMan.position.y - currentGroundY) < 0.1) {
            velocityY = JUMP_FORCE;
        }
    }

    function handleKeyDown(e) {
        if (e.code === 'KeyA' || e.code === 'ArrowLeft') moveLane(-1);
        if (e.code === 'KeyD' || e.code === 'ArrowRight') moveLane(1);
        if (e.code === 'KeyW' || e.code === 'Space' || e.code === 'ArrowUp') handleJump();
        if (e.code === 'KeyS' || e.code === 'ArrowDown') {
            if (velocityY > 0) velocityY = 0;
            velocityY -= 0.4;
        }
    }

    function startGame() {
        score = 0; speed = 0.25; currentLaneIndex = 1; targetX = LANES[1];
        mokaMan.position.set(targetX, PLAYER_Y_OFFSET, 0);
        velocityY = 0; magnetTimer = 0; shieldTimer = 0;
        scoreEl.innerText = score;
        entities.forEach(e => scene.remove(e.mesh));
        entities = [];
        gameActive = true;
        menu.classList.add('hidden');
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let spawnDist = 0;
    function animate() {
        requestAnimationFrame(animate);
        if (gameActive) {
            speed += 0.00008;

            // Movement
            mokaMan.position.x += (targetX - mokaMan.position.x) * 0.2;

            // Detect Platform Ground
            let checkGroundY = PLAYER_Y_OFFSET;
            entities.forEach(e => {
                if (e.type === 'carton' && e.lane === currentLaneIndex) {
                    const dz = Math.abs(mokaMan.position.z - e.mesh.position.z);
                    // Check if player is on top of carton
                    if (dz < (CARTON_LENGTH / 2 + 0.5)) {
                        // Only "land" if player is above the carton
                        if (mokaMan.position.y >= CARTON_HEIGHT + 0.2) {
                            checkGroundY = CARTON_HEIGHT + PLAYER_Y_OFFSET;
                        }
                    }
                }
            });
            currentGroundY = checkGroundY;

            // Gravity
            velocityY += GRAVITY;
            mokaMan.position.y += velocityY;
            if (mokaMan.position.y < currentGroundY) {
                mokaMan.position.y = currentGroundY;
                velocityY = 0;
            }

            // Spawning rows
            spawnDist += speed;
            if (spawnDist > 40) {
                spawnRow();
                spawnDist = 0;
            }

            // Powerup Timers
            if (magnetTimer > 0) magnetTimer--;
            if (shieldTimer > 0) shieldTimer--;
            magnetUI.style.display = magnetTimer > 0 ? 'block' : 'none';
            shieldUI.style.display = shieldTimer > 0 ? 'block' : 'none';
            if (magnetTimer > 0) magnetUI.children[0].style.width = (magnetTimer/600*100)+'%';
            if (shieldTimer > 0) shieldUI.children[0].style.width = (shieldTimer/600*100)+'%';
            shieldBubble.visible = shieldTimer > 0;

            // Entities update
            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                e.mesh.position.z += speed;

                const dz = mokaMan.position.z - e.mesh.position.z;
                const distZ = Math.abs(dz);
                const sameLane = e.lane === currentLaneIndex;

                if (e.type === 'bean') {
                    if (magnetTimer > 0 && mokaMan.position.distanceTo(e.mesh.position) < 15) {
                        e.mesh.position.x += (mokaMan.position.x - e.mesh.position.x) * 0.2;
                        e.mesh.position.y += (mokaMan.position.y - e.mesh.position.y) * 0.2;
                    }
                    if (mokaMan.position.distanceTo(e.mesh.position) < 1.2) {
                        score += 100; scoreEl.innerText = score;
                        scene.remove(e.mesh); entities.splice(i, 1);
                        continue;
                    }
                }

                // Powerups
                if (e.type.startsWith('power') && mokaMan.position.distanceTo(e.mesh.position) < 1.5) {
                    if (e.type === 'power_magnet') magnetTimer = 600;
                    else shieldTimer = 600;
                    scene.remove(e.mesh); entities.splice(i, 1);
                    continue;
                }

                // Collision Logic
                if (sameLane) {
                    if (e.type === 'carton') {
                        // Frontal collision: Player is at Z=0. Carton center at Z_e.
                        // Carton face at Z_e + 6. If dz is approx -6, we hit the face.
                        if (dz < -5.5 && dz > -6.5 && mokaMan.position.y < CARTON_HEIGHT) {
                            handleCollision();
                        }
                    } else if (e.type === 'spill' && distZ < 1.2 && mokaMan.position.y < 1.0) {
                        handleCollision();
                    } else if (e.type === 'ramp' && distZ < (RAMP_LENGTH/2 + 0.5)) {
                        // If player is on ramp, propel up
                        if (mokaMan.position.y < CARTON_HEIGHT + 0.5) {
                            // Simple linear ascent based on Z position inside ramp
                            const progress = (dz + RAMP_LENGTH/2) / RAMP_LENGTH;
                            const targetY = THREE.MathUtils.lerp(PLAYER_Y_OFFSET, CARTON_HEIGHT + PLAYER_Y_OFFSET, progress);
                            if (mokaMan.position.y < targetY) mokaMan.position.y = targetY;
                            velocityY = 0.1; // Small boost
                        }
                    }
                }

                if (e.mesh.position.z > 20) {
                    scene.remove(e.mesh); entities.splice(i, 1);
                    score += 5; scoreEl.innerText = score;
                }
            }

            mokaMan.rotation.z = (mokaMan.position.x - targetX) * 0.3;
            mokaMan.rotation.x = -velocityY * 0.3;
        }
        renderer.render(scene, camera);
    }

    function handleCollision() {
        if (shieldTimer > 0) {
            shieldTimer = 0;
            // Temporary invincibility could go here
        } else {
            gameActive = false;
            menu.classList.remove('hidden');
            menuTitle.innerText = "OVERBREWED!";
            menuText.innerText = `Final Score: ${score}`;
            startBtn.innerText = "RE-BREW";
        }
    }

    init();
</script>
</body>
</html>
